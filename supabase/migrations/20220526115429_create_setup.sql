-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE OR REPLACE FUNCTION public.handle_new_user()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
AS $BODY$
begin
  insert into public.users (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$BODY$;

ALTER FUNCTION public.handle_new_user()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO authenticated;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO anon;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO service_role;

CREATE TABLE IF NOT EXISTS public.products
(
    id text COLLATE pg_catalog."default" NOT NULL,
    active boolean,
    name text COLLATE pg_catalog."default",
    description text COLLATE pg_catalog."default",
    image text COLLATE pg_catalog."default",
    metadata jsonb,
    CONSTRAINT products_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.products
    OWNER to postgres;

ALTER TABLE IF EXISTS public.products
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.products TO anon;

GRANT ALL ON TABLE public.products TO authenticated;

GRANT ALL ON TABLE public.products TO postgres;

GRANT ALL ON TABLE public.products TO service_role;
CREATE POLICY "Allow public read-only access."
    ON public.products
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TABLE IF NOT EXISTS public.calls
(
    -- id integer NOT NULL DEFAULT nextval('calls_id_seq'::regclass),
    id serial NOT NULL,
    user_id uuid NOT NULL,
    endpoint text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT calls_pkey PRIMARY KEY (id),
    CONSTRAINT calls_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.calls
    OWNER to postgres;

ALTER TABLE IF EXISTS public.calls
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.calls TO anon;

GRANT ALL ON TABLE public.calls TO authenticated;

GRANT ALL ON TABLE public.calls TO postgres;

GRANT ALL ON TABLE public.calls TO service_role;
CREATE POLICY "Can only view own calls data."
    ON public.calls
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = user_id));

CREATE TABLE IF NOT EXISTS public.users
(
    id uuid NOT NULL,
    full_name text COLLATE pg_catalog."default",
    avatar_url text COLLATE pg_catalog."default",
    billing_address jsonb,
    payment_method jsonb,
    api_token text COLLATE pg_catalog."default" NOT NULL DEFAULT uuid_generate_v1(),
    CONSTRAINT users_pkey PRIMARY KEY (id),
    CONSTRAINT users_api_token_key UNIQUE (api_token),
    CONSTRAINT users_id_fkey FOREIGN KEY (id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.users
    OWNER to postgres;

ALTER TABLE IF EXISTS public.users
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.users TO authenticated;

GRANT ALL ON TABLE public.users TO anon;

GRANT ALL ON TABLE public.users TO service_role;

GRANT ALL ON TABLE public.users TO postgres;
CREATE POLICY "Can update own user data."
    ON public.users
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = id));
CREATE POLICY "Can view own user data."
    ON public.users
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = id));

CREATE TABLE IF NOT EXISTS public.customers
(
    id uuid NOT NULL,
    stripe_customer_id text COLLATE pg_catalog."default",
    CONSTRAINT customers_pkey PRIMARY KEY (id),
    CONSTRAINT customers_id_fkey FOREIGN KEY (id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.customers
    OWNER to postgres;

ALTER TABLE IF EXISTS public.customers
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.customers TO anon;

GRANT ALL ON TABLE public.customers TO authenticated;

GRANT ALL ON TABLE public.customers TO postgres;

GRANT ALL ON TABLE public.customers TO service_role;


-- Type: subscription_status

-- DROP TYPE IF EXISTS public.subscription_status;

CREATE TYPE public.subscription_status AS ENUM
    ('trialing', 'active', 'canceled', 'incomplete', 'incomplete_expired', 'past_due', 'unpaid');

ALTER TYPE public.subscription_status
    OWNER TO postgres;

-- Type: pricing_plan_interval

-- DROP TYPE IF EXISTS public.pricing_plan_interval;

CREATE TYPE public.pricing_plan_interval AS ENUM
    ('day', 'week', 'month', 'year');

ALTER TYPE public.pricing_plan_interval
    OWNER TO postgres;

-- Type: pricing_type

-- DROP TYPE IF EXISTS public.pricing_type;

CREATE TYPE public.pricing_type AS ENUM
    ('one_time', 'recurring');

ALTER TYPE public.pricing_type
    OWNER TO postgres;

CREATE TABLE IF NOT EXISTS public.prices
(
    id text COLLATE pg_catalog."default" NOT NULL,
    product_id text COLLATE pg_catalog."default",
    active boolean,
    description text COLLATE pg_catalog."default",
    unit_amount bigint,
    currency text COLLATE pg_catalog."default",
    type pricing_type,
    "interval" pricing_plan_interval,
    interval_count integer,
    trial_period_days integer,
    metadata jsonb,
    CONSTRAINT prices_pkey PRIMARY KEY (id),
    CONSTRAINT prices_product_id_fkey FOREIGN KEY (product_id)
        REFERENCES public.products (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT prices_currency_check CHECK (char_length(currency) = 3)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.prices
    OWNER to postgres;

ALTER TABLE IF EXISTS public.prices
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.prices TO authenticated;

GRANT ALL ON TABLE public.prices TO anon;

GRANT ALL ON TABLE public.prices TO service_role;

GRANT ALL ON TABLE public.prices TO postgres;
CREATE POLICY "Allow public read-only access."
    ON public.prices
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

CREATE TABLE IF NOT EXISTS public.subscriptions
(
    id text COLLATE pg_catalog."default" NOT NULL,
    user_id uuid NOT NULL,
    status subscription_status,
    metadata jsonb,
    price_id text COLLATE pg_catalog."default",
    quantity integer,
    cancel_at_period_end boolean,
    created timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
    current_period_start timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
    current_period_end timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
    ended_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    cancel_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    canceled_at timestamp with time zone DEFAULT timezone('utc'::text, now()),
    trial_start timestamp with time zone DEFAULT timezone('utc'::text, now()),
    trial_end timestamp with time zone DEFAULT timezone('utc'::text, now()),
    CONSTRAINT subscriptions_pkey PRIMARY KEY (id),
    CONSTRAINT subscriptions_price_id_fkey FOREIGN KEY (price_id)
        REFERENCES public.prices (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT subscriptions_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.subscriptions
    OWNER to postgres;

ALTER TABLE IF EXISTS public.subscriptions
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.subscriptions TO authenticated;

GRANT ALL ON TABLE public.subscriptions TO anon;

GRANT ALL ON TABLE public.subscriptions TO service_role;

GRANT ALL ON TABLE public.subscriptions TO postgres;
CREATE POLICY "Can only view own subs data."
    ON public.subscriptions
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.uid() = user_id));
